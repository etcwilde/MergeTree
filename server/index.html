<html>
<head>
    <meta charset="utf-8">
    <title>Test</title>
    <!-- <script src="https://bitbucket.org/atlassian-connect/all.js"></script> -->

    <link rel="stylesheet" href="css/base.css" type="text/css" media="all" />

    <script src="js/Network.js"></script> <!-- For loading data -->

    <script src="js/Queue.js"></script>
    <script src="js/Stack.js"></script>
    <script src="js/Tree.js"></script>

    <script src="js/Processing.js"></script>

    <script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="js/vistree.js"></script>
</head>
<body>
    <h1>Merge Tree</h1>

    <div>
        <input type="search" name="repoName" id="repoName_search" placeholder="user/repo"/>
        <input type="text" name="repoPage" id="repoPage_text" placeholder="page number" value="" />
        <input type="button" name="clear" id="clear_button" value="Clear" />
    </div>

    <div id="content_table" class="left">
    </div>

    <div id="content_graph" class="left"> </div>


    <script type="text/javascript" charset="utf-8">

    var contentNode = document.getElementById('content_table');
    var searchNode = document.getElementById('repoName_search');
    var pageNode = document.getElementById('repoPage_text');
    var clearNode = document.getElementById('clear_button');

    var clear = function() {
        while (contentNode.firstChild) {
            contentNode.removeChild(contentNode.firstChild);
        }

        while (document.getElementById('content_graph').firstChild) {
            document.getElementById('content_graph').removeChild(document.getElementById('content_graph').firstChild);
        }

    }

    // Database of all commits -- probably a better way to store this info
    var lookupTable = {};

    function populateLookupTable(commits) {
        for (var node of commits) {
            lookupTable[node.hash] = node;
        }
    }

    function constructParentTable(commits) {
        var tableElement = document.createElement("table");
        tableElement.style.border = "thick solid #eeeeee";
        contentNode.append(tableElement);
        let row = document.createElement("tr");
        row.append(function() { let item = document.createElement("th");
            item.innerHTML = "Log";
            return item;
        }());
        row.append(function() { let item = document.createElement("th");
            item.innerHTML = "Parents";
            return item;
        }());
        tableElement.append(row);
        for (var com of commits) {
            let row = document.createElement("tr");
            row.append(function() {
                let item = document.createElement("td");
                item.innerHTML = com[0];
                return item;
            }());

            row.append(function() {
                let entry = document.createElement("td");
                let listItem = document.createElement("ol");
                for (let par of com[1]) {
                    let item = document.createElement('li');
                    item.innerHTML = par;
                    listItem.append(item);
                }
                entry.append(listItem);
                return entry;
            }());
            tableElement.append(row);
        }
    }

    function buildMergeTree(rootNode) {
        var depth = 0;
        var nodeQueue = new Queue();
        var retTree = new Tree();
        var children = {};

        nodeQueue.push(rootNode.key);

        // First-pass, finding all the children
        // Gets the smallest possible subset of the repository necessary for merge
        // tree construction
        do {
            let cur = nodeQueue.pop();
            // FIXME: Need a way to know when we've actually finished downloading
            let parentList = lookupTable[cur].parents.map(function(par){
                if (!(par.hash in lookupTable)){
                    console.error(par.hash, "not in lookup table, downloading:", par.links.self.href);
                    request({
                        url: par.links.self.href,
                        success: function(resp) { lookupTable[par.hash] = resp;},
                        error: console.error
                    });
                }
                // FIXME: We move on too quickly
                // Increase the number of children
                (par.hash in children) ? children[par.hash].push(cur) : children[par.hash] = [cur];
                return par.hash;
            });

            let removal = ((children[parentList[0]]) ?  children[parentList[0]].length : 0);
            depth += parentList.length - removal;
            parentList.forEach(function(item){
                nodeQueue.push(item);
            });
        } while (nodeQueue.size() > 0 && depth != 0);

        // Pass two, constructing the tree

        retTree.add(rootNode);
        nodeQueue.clear();
        nodeQueue.push(rootNode);
        depth = 0;
        do {
            let cur = nodeQueue.pop();
            let parentList = lookupTable[cur.key].parents.map(function(par){
                if(!(par.hash in lookupTable)) {
                    console.error(par.hash, "not found in lookup table... There was a problem downloading it");
                }
                return par.hash;
            });

            let old_length = parentList.length;
            if (depth == 0) { parentList.shift(); }
            if (old_length > 1){ depth+= parentList.length; }

            parentList.forEach(function(item, index){
                let newNode = new TreeNode(item);
                let addNode = null,
                setfunc = function(node) { addNode = node;};

                if(children[item].length > 1) {
                    depth--;
                }

                // Only continue working with nodes for which we are the primary
                // parent
                if(children[item][0] == cur.key) {
                    cur.children.push(newNode);
                    newNode.parent = cur;
                    nodeQueue.push(newNode);
                }
            })

        } while (nodeQueue.size() > 0 && depth != 0);

        return retTree;

    }



    var formHandler = function() {
        var loadMaster = function(masterName) {
            var u = 'https://api.bitbucket.org/2.0/repositories/' + searchNode.value
                + "/commits/" + masterName.name;
            u += (pageNode.value === "" || pageNode.value === "0") ? "" : "?page=" + pageNode.value;
            request({
                url: u,
                success: function(resp) {
                    var commit_data = resp.values.map(function(val) {
                        var ret_arr = [val.hash, val.parents.map(function(par) {
                            return par.hash; })];
                        return ret_arr;});


                    var mergeCommits = resp.values.filter(function(val) { return val.parents.length > 1; }).map(function(val) { return val.hash; });

                    populateLookupTable(resp.values);
                    constructParentTable(commit_data);

                    // For now
                    let build = function (value){
                        let tree = buildMergeTree(new TreeNode(value));
                        let rt = new ReingoldTree(tree, lookupTable);
                        rt.draw(d3.select("#content_graph"));
                    }(mergeCommits[0]);

                    // Process the array asynchronously, building each tree
                    // processArray(mergeCommits, function(value){
                    //     let tree = buildMergeTree(new TreeNode(value));
                    //     let rt = new ReingoldTree(tree, lookupTable);
                    //     rt.draw(d3.select("#content_graph"));
                    // });

                },
                error: function(resp) { contentNode.append("An Error occured getting data for " + searchNode.value);}
            });
        }

        request({
            url: 'https://api.bitbucket.org/1.0/repositories/' + searchNode.value + "/main-branch",
            success: loadMaster,
            error: function(resp) { content.innerHTML = "An error " + resp + " occured when getting the main branch name for the repository";}
        });

    }
    searchNode.addEventListener('search', formHandler);
    pageNode.addEventListener('keypress', function(e){if (e.keyCode === 13) formHandler()});
    clearNode.addEventListener('click', clear)
    </script>


    </body>
</html>
